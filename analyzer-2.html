<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>تحليل الصورة المباشر</title>
  <style>
    canvas { border: 1px solid #ccc; margin: 10px; }
  </style>
</head>
<body>
  <video id="video" autoplay></video>
  <button onclick="captureAndAnalyze()">تحليل مباشر</button>
  <canvas id="canvas"></canvas>
  <canvas id="matchCanvas" width="300" height="150"></canvas>
  <script>
    // ✅ تهيئة الفيديو
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => video.srcObject = stream);

    function captureAndAnalyze() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0);

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const grayscaleData = toGrayscale(imageData);
      const blocks = extractBlocks(grayscaleData, canvas.width);

      const [blockA, blockB] = findMostSimilarPair(blocks);
      drawMatchingBlocks(blockA, blockB);
    }

    // ✅ تحويل لصيغة الرماديات
    function toGrayscale(imageData) {
      const gray = new Uint8ClampedArray(imageData.data.length / 4);
      for (let i = 0; i < gray.length; i++) {
        const r = imageData.data[i * 4];
        const g = imageData.data[i * 4 + 1];
        const b = imageData.data[i * 4 + 2];
        gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;
      }
      return gray;
    }

    // ✅ استخراج مربعات صغيرة من الصورة
    function extractBlocks(gray, width) {
      const blockSize = 32;
      const blocks = [];
      for (let y = 0; y < gray.length / width - blockSize; y += blockSize) {
        for (let x = 0; x < width - blockSize; x += blockSize) {
          const block = [];
          for (let j = 0; j < blockSize; j++) {
            for (let i = 0; i < blockSize; i++) {
              const idx = (y + j) * width + (x + i);
              block.push(gray[idx]);
            }
          }
          blocks.push({ x, y, data: block, width: blockSize });
        }
      }
      return blocks;
    }

    // ✅ حساب GLCM (الاتجاه 0 درجة فقط للتبسيط)
    function computeGLCM(block) {
      const glcm = Array.from({ length: 256 }, () => Array(256).fill(0));
      for (let i = 0; i < block.data.length - 1; i++) {
        const a = block.data[i];
        const b = block.data[i + 1];
        glcm[a][b]++;
      }
      return glcm;
    }

    // ✅ مقارنة GLCM (بسيط: مجموع الفروق المطلقة)
    function compareGLCM(glcmA, glcmB) {
      let score = 0;
      for (let i = 0; i < 256; i++) {
        for (let j = 0; j < 256; j++) {
          score += 1 - Math.abs(glcmA[i][j] - glcmB[i][j]) / Math.max(glcmA[i][j] + glcmB[i][j], 1);
        }
      }
      return score;
    }

    // ✅ تحديد أكثر زوج متشابه
    function findMostSimilarPair(blocks) {
      let bestScore = -Infinity;
      let pair = [null, null];
      for (let i = 0; i < blocks.length; i++) {
        for (let j = i + 1; j < blocks.length; j++) {
          const glcmA = computeGLCM(blocks[i]);
          const glcmB = computeGLCM(blocks[j]);
          const score = compareGLCM(glcmA, glcmB);
          if (score > bestScore) {
            bestScore = score;
            pair = [blocks[i], blocks[j]];
          }
        }
      }
      return pair;
    }

    // ✅ عرض المربعين داخل matchCanvas
    function drawMatchingBlocks(blockA, blockB) {
      const matchCanvas = document.getElementById('matchCanvas');
      const ctx = matchCanvas.getContext('2d');
      const imgData = ctx.createImageData(blockA.width, blockA.width);

      // تحويل بيانات الرماديات إلى RGBA لكل مربع
      function fillImageData(block, offsetX) {
        const tempData = ctx.createImageData(block.width, block.width);
        for (let i = 0; i < block.data.length; i++) {
          tempData.data[i * 4] = block.data[i];
          tempData.data[i * 4 + 1] = block.data[i];
          tempData.data[i * 4 + 2] = block.data[i];
          tempData.data[i * 4 + 3] = 255;
        }
        ctx.putImageData(tempData, offsetX, 0);
      }

      fillImageData(blockA, 0);
      fillImageData(blockB, blockA.width + 10);
    }
  </script>
</body>
</html>
